#!/usr/bin/python

from ProcMgr import ProcMgr, deduce_platform, getConfigFileNames
from optparse import OptionParser
from string import atoi
import os.path
from os import remove, symlink
import sys
import shutil
import filecmp

#
# _stop
#
def _stop(argv0, args, runconfig, lastconfig, configfile, options):
    _stop_rv = 1    # return value
    try:
        if os.path.isfile(runconfig):
            # stop dynamic processes
            print "%s: using config file '%s' to stop" % (argv0, runconfig)
            handle = ProcMgr(runconfig,options.platform)
            handle.stop(args, verbose=options.verbose, sigdelay=options.sigint_delay, only_static=0)
            staticCount, dynamicCount = handle.getProcessCounts()
            if dynamicCount == 0:
                os.remove(runconfig)
                print "%s: removed '%s'" % (argv0, runconfig)
                _stop_rv = 0
        elif os.path.isfile(lastconfig):
            # stop dynamic processes
            print "%s: using config file '%s' to stop" % (argv0, lastconfig)
            handle = ProcMgr(lastconfig,options.platform)
            handle.stop(args, verbose=options.verbose, sigdelay=options.sigint_delay, only_static=0)
        elif os.path.isfile(configfile):
            # stop dynamic processes
            print "%s: using config file '%s' to stop" % (argv0, configfile)
            handle = ProcMgr(configfile,options.platform)
            handle.stop(args, verbose=options.verbose, sigdelay=options.sigint_delay, only_static=0)
        elif len(args) == 0:
            # nothing to stop
            print "%s: no dynamic processes running ('%s' not found)" % (argv0, runconfig)
            _stop_rv = 1
        else:
            # stop static processes listed on command line
            print "%s: using config file '%s' to stop" % (argv0, configfile)
            _stop_rv = ProcMgr(configfile,options.platform).stop(args, options.verbose,
                    options.sigint_delay, only_static=1)
    except IOError:
        print "%s: i/o error" % argv0
        _stop_rv = 1

    return _stop_rv

#
# _start
#
def _start(argv0, args, runconfig, lastconfig, configfile, options):
    _start_rv = 1   # return value
    if os.path.exists(runconfig):
        print "It is necessary to stop the running config before starting '%s'." % configfile
        print "If this is incorrect, remove '%s'." % runconfig
    else:
        try:
            print "%s: using config file '%s' to start" % (argv0, configfile)
            handle = ProcMgr(configfile, options.platform)
            _start_rv = handle.start(args, options.verbose, options.logpath, options.coresize)
            staticCount, dynamicCount = handle.getProcessCounts()
        except IOError:
            print "%s: i/o error" % argv0
            _start_rv = 1
        else:
            if (_start_rv == 0) and (dynamicCount > 0):
                # copy cnf to cnf.last, then link to cnf.running to cnf.last
                try:
                    if not os.path.exists(lastconfig):
                        shutil.copyfile(configfile, lastconfig)
                    elif filecmp.cmp(configfile, lastconfig) == 0:
                        shutil.copyfile(configfile, lastconfig)

                    if os.path.exists(lastconfig):
                        os.symlink(os.path.basename(lastconfig), runconfig)
                    else:
                        print "%s: '%s' not found" % (sys.argv0, lastconfig)
                        _start_rv = 1
                    
                except IOError:
                    print "%s: i/o error updating %s and %s" % (sys.argv0, runconfig, lastconfig)
                    _start_rv = 1

    return _start_rv

#
# _status
#
def _status(argv0, args, lastconfig, configfile, options):
    _status_rv = 1    # return value
    try:
        if os.path.exists(lastconfig):
            print "%s: using config file '%s'" % (sys.argv[0], lastconfig)
            _status_rv = ProcMgr(lastconfig, options.platform).status(args, verbose=options.verbose,
                         only_static=0)
        else:
            print "%s: using config file '%s'" % (sys.argv[0], configfile)
            _status_rv = ProcMgr(configfile, options.platform).status(args, verbose=options.verbose,
                         only_static=1)
    except IOError:
        print "%s: i/o error" % sys.argv[0]
        _status_rv = 1

    return _status_rv


rv = 1      # return value

command_list = [ 'start', 'stop', 'restart', 'status' ]

usage = "usage: %prog { start | stop | restart | status } configfile [-h] [-v] [-p <platform>] [-c <coresize>] [-t <secs>] [-o <logpath>] [UNIQUEID]..."

parser = OptionParser(usage=usage)

parser.add_option("-v", "--verbose",
                  action="store_true", dest="verbose", default=False,
                  help="be verbose")

parser.add_option("-p", type="int", dest="platform", metavar="<platform>",
                  default=-1, help="platform number")

parser.add_option("-c", type="int", dest="coresize", metavar="<coresize>",
                  default=2000000000, help="max core dump size (default=2000000000)")

parser.add_option("-t", type="int", dest="sigint_delay", metavar="<secs>",
                  default=1, help="for stop and restart: delay between SIGINT and SIGTERM (default=1)")

homedir = os.path.expanduser('~')
parser.add_option("-o", type="string", dest="logpath", metavar="<logpath>",
                  default=homedir,
                  help="output directory (default=%s)" % homedir)

(options, args) = parser.parse_args()

if len(args) < 2:
    parser.error("at least two arguments required")

configfile = args.pop(1)

if os.path.isfile(configfile) != 1:
    parser.error ("file not found: %s" % configfile)

if (options.platform < 0):
    try:
        options.platform = deduce_platform(configfile)
    except IOError:
        print 'I/O error while reading file', configfile
        options.platform = -1

if (options.platform < 0):
    parser.error("must specify platform")

runconfig, lastconfig = getConfigFileNames(configfile, options.platform)

command = args.pop(0)

if not command in command_list:
    parser.error ("unknown command: %s" % command)

if command == 'start':
    # start
    rv = _start(sys.argv[0], args, runconfig, lastconfig, configfile, options)

elif command == 'status':
    # status
    rv = _status(sys.argv[0], args, lastconfig, configfile, options)

elif command == 'stop':
    # stop
    rv = _stop(sys.argv[0], args, runconfig, lastconfig, configfile, options)

elif command == 'restart':
    # stop
    rv = _stop(sys.argv[0], args, runconfig, lastconfig, configfile, options)
    if rv != 0:
      print "%s: error occurred during stop" % sys.argv[0]
    # start
    rv = _start(sys.argv[0], args, runconfig, lastconfig, configfile, options)

else:

    # should not get here
    parser.error ("invalid command")
    rv = 1

sys.exit(rv)
