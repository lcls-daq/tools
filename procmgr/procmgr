#!/usr/bin/python

from ProcMgr import ProcMgr, deduce_platform, getConfigFileNames
from optparse import OptionParser
from string import atoi
import os.path
from os import remove, symlink
import sys
import shutil
import filecmp

rv = 1      # return value

command_list = [ 'start', 'stop', 'status' ]

usage = "usage: %prog { start | stop | status } configfile [-h] [-v] [-p <platform>] [-c <coresize>] [-t <secs>] [-o <logpath>] [UNIQUEID]..."

parser = OptionParser(usage=usage)

parser.add_option("-v", "--verbose",
                  action="store_true", dest="verbose", default=False,
                  help="be verbose")

parser.add_option("-p", type="int", dest="platform", metavar="<platform>",
                  default=-1, help="platform number")

parser.add_option("-c", type="int", dest="coresize", metavar="<coresize>",
                  default=2000000000, help="max core dump size (default=2000000000)")

parser.add_option("-t", type="int", dest="sigint_delay", metavar="<secs>",
                  default=1, help="for stop: delay between SIGINT and SIGTERM (default=1)")

homedir = os.path.expanduser('~')
parser.add_option("-o", type="string", dest="logpath", metavar="<logpath>",
                  default=homedir,
                  help="output directory (default=%s)" % homedir)

(options, args) = parser.parse_args()

if len(args) < 2:
    parser.error("at least two arguments required")

configfile = args.pop(1)

if os.path.isfile(configfile) != 1:
    parser.error ("file not found: %s" % configfile)

if (options.platform < 0):
    try:
        options.platform = deduce_platform(configfile)
    except IOError:
        print 'I/O error while reading file', configfile
        options.platform = -1

if (options.platform < 0):
    parser.error("must specify platform")

runconfig, lastconfig = getConfigFileNames(configfile, options.platform)

command = args.pop(0)

if not command in command_list:
    parser.error ("unknown command: %s" % command)

if command == 'start':

    # start

    if os.path.exists(runconfig):
        print "It is necessary to stop the running config before starting '%s'." % configfile
        print "If this is incorrect, remove '%s'." % runconfig
    else:
        try:
            print "%s: using config file '%s'" % (sys.argv[0], configfile)
            handle = ProcMgr(configfile, options.platform)
            rv = handle.start(args, options.verbose, options.logpath, options.coresize)
            staticCount, dynamicCount = handle.getProcessCounts()
        except IOError:
            print "%s: i/o error" % sys.argv[0]
            rv = 1
        else:
            if (rv == 0) and (dynamicCount > 0):
                # copy cnf to cnf.last, then link to cnf.running to cnf.last
                try:
                    if not os.path.exists(lastconfig):
                        shutil.copyfile(configfile, lastconfig)
                    elif filecmp.cmp(configfile, lastconfig) == 0:
                        shutil.copyfile(configfile, lastconfig)

                    if os.path.exists(lastconfig):
                        os.symlink(os.path.basename(lastconfig), runconfig)
                    else:
                        print "%s: '%s' not found" % (sys.argv[0], lastconfig)
                        rv = 1
                    
                except IOError:
                    print "%s: i/o error updating %s and %s" % (sys.argv[0], runconfig, lastconfig)
                    rv = 1

elif command == 'status':

    # status

    try:
        if os.path.exists(lastconfig):
            print "%s: using config file '%s'" % (sys.argv[0], lastconfig)
            rv = ProcMgr(lastconfig, options.platform).status(args, verbose=options.verbose,
                         only_static=0)
        else:
            print "%s: using config file '%s'" % (sys.argv[0], configfile)
            rv = ProcMgr(configfile, options.platform).status(args, verbose=options.verbose,
                         only_static=1)
    except IOError:
        print "%s: i/o error" % sys.argv[0]
        rv = 1

elif command == 'stop':

    # stop

    try:
        if os.path.isfile(runconfig):
            # stop dynamic processes
            print "%s: using config file '%s'" % (sys.argv[0], runconfig)
            handle = ProcMgr(runconfig,options.platform)
            handle.stop(args, verbose=options.verbose, sigdelay=options.sigint_delay, only_static=0)
            staticCount, dynamicCount = handle.getProcessCounts()
            if dynamicCount == 0:
                os.remove(runconfig)
                print "%s: removed '%s'" % (sys.argv[0], runconfig)
                rv = 0
        elif os.path.isfile(lastconfig):
            # stop dynamic processes
            print "%s: using config file '%s'" % (sys.argv[0], lastconfig)
            handle = ProcMgr(lastconfig,options.platform)
            handle.stop(args, verbose=options.verbose, sigdelay=options.sigint_delay, only_static=0)
        elif os.path.isfile(configfile):
            # stop dynamic processes
            print "%s: using config file '%s'" % (sys.argv[0], configfile)
            handle = ProcMgr(configfile,options.platform)
            handle.stop(args, verbose=options.verbose, sigdelay=options.sigint_delay, only_static=0)
        elif len(args) == 0:
            # nothing to stop
            print "%s: no dynamic processes running ('%s' not found)" % (sys.argv[0], runconfig)
            rv = 1
        else:
            # stop static processes listed on command line
            print "%s: using config file '%s'" % (sys.argv[0], configfile)
            rv = ProcMgr(configfile,options.platform).stop(args, options.verbose,
                    options.sigint_delay, only_static=1)
    except IOError:
        print "%s: i/o error" % sys.argv[0]
        rv = 1

else:

    # should not get here
    parser.error ("invalid command")
    rv = 1

sys.exit(rv)
